PROMPT UPGRADE — ADMIN PANEL + IMPERSONATE + GLOBAL STATS (React + Express + Prisma + JWT)

Estendi il progetto TapReview (stack: React+Vite, Express, Prisma, JWT) aggiungendo pannello amministratore.

0) Prerequisiti

Esiste già auth con cookie httpOnly token e requireAuth.

(Se presente il tracciamento click) tabella Click o campo Link.clicks. Se non c’è Click, le stats “7/30 giorni” possono restituire 0 (fallback accettabile).

1) Prisma: ruolo utente

In server/prisma/schema.prisma aggiungi:

enum Role {
  USER
  ADMIN
}

model User {
  id        Int       @id @default(autoincrement())
  email     String    @unique
  password  String
  username  String    @unique
  createdAt DateTime  @default(now())
  role      Role      @default(USER)  // <— NEW
  links     Link[]
  profile   Profile?
}


Se non esiste il modello Click, lascia così. Se esiste, non toccarlo.

Esegui migrazione:

cd server
npx prisma generate
npx prisma migrate dev --name add_role_admin

2) Middleware admin

Crea server/src/middleware/requireAdmin.ts:

import { Request, Response, NextFunction } from "express";
import { PrismaClient } from "@prisma/client";
import { getUserIdFromRequest } from "../utils/user-from-request";
const prisma = new PrismaClient();

export async function requireAdmin(req: Request, res: Response, next: NextFunction) {
  const userId = await getUserIdFromRequest(req);
  if (!userId) return res.status(401).json({ message: "Non autenticato" });
  const user = await prisma.user.findUnique({ where: { id: userId } });
  if (!user || user.role !== "ADMIN") {
    return res.status(403).json({ message: "Solo admin" });
  }
  // attach admin to request for later use
  (req as any).admin = user;
  next();
}


Crea util per estrarre l’utente dal cookie JWT server/src/utils/user-from-request.ts:

import type { Request } from "express";
import jwt from "jsonwebtoken";

export async function getUserIdFromRequest(req: Request): Promise<number|null> {
  const token = req.cookies?.token;
  if (!token) return null;
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET as string) as any;
    return payload?.id ?? null;
  } catch {
    return null;
  }
}

3) Rotte Admin (lista utenti, stats, impersonate)

Crea server/src/routes/admin.ts:

import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import jwt from "jsonwebtoken";

const prisma = new PrismaClient();
const router = Router();

/** Utils */
function signToken(payload: object) {
  return jwt.sign(payload, process.env.JWT_SECRET as string, { expiresIn: "30d" });
}

/** GET /api/admin/users?query=&page=1&pageSize=20
 *  Lista utenti con counts basilari.
 */
router.get("/users", async (req, res) => {
  const q = String(req.query.query || "").trim();
  const page = Number(req.query.page || 1);
  const pageSize = Number(req.query.pageSize || 20);
  const skip = (page - 1) * pageSize;

  const where = q
    ? {
        OR: [
          { email: { contains: q, mode: "insensitive" } },
          { username: { contains: q, mode: "insensitive" } },
          { profile: { is: { displayName: { contains: q, mode: "insensitive" } } } },
        ],
      }
    : {};

  const [total, users] = await Promise.all([
    prisma.user.count({ where }),
    prisma.user.findMany({
      where,
      include: {
        _count: { select: { links: true } },
      },
      orderBy: { createdAt: "desc" },
      skip,
      take: pageSize,
    }),
  ]);

  res.json({ total, page, pageSize, users });
});

/** GET /api/admin/stats/summary
 *  Ritorna stats globali (utenti, link, click).
 *  Se esiste tabella Click, calcola 7/30 giorni. Altrimenti 0.
 */
router.get("/stats/summary", async (_req, res) => {
  const [usersCount, linksCount] = await Promise.all([
    prisma.user.count(),
    prisma.link.count(),
  ]);

  // All-time clicks
  let clicksAllTime = 0;
  try {
    // Se esiste colonna clicks su Link (contatore veloce)
    const links = await prisma.link.findMany({ select: { clicks: true } as any });
    if (links.length) {
      clicksAllTime = links.reduce((a: number, b: any) => a + (b.clicks || 0), 0);
    }
  } catch {
    // Se non esiste la colonna clicks, prova tabella Click
    try {
      clicksAllTime = await prisma.click.count();
    } catch {
      clicksAllTime = 0;
    }
  }

  // 7 / 30 giorni se c'è tabella Click
  let clicks7d = 0, clicks30d = 0;
  try {
    const now = new Date();
    const d7 = new Date(now); d7.setDate(now.getDate() - 7);
    const d30 = new Date(now); d30.setDate(now.getDate() - 30);
    clicks7d = await prisma.click.count({ where: { createdAt: { gte: d7 } } as any });
    clicks30d = await prisma.click.count({ where: { createdAt: { gte: d30 } } as any });
  } catch {
    clicks7d = 0; clicks30d = 0;
  }

  res.json({ usersCount, linksCount, clicksAllTime, clicks7d, clicks30d });
});

/** POST /api/admin/impersonate/:userId
 *  Impersona un utente: salva cookie 'token' dell'UTENTE e un cookie 'impersonator'
 *  firmato con l'ID dell'admin, per poter tornare indietro.
 */
router.post("/impersonate/:userId", async (req: any, res) => {
  const targetId = Number(req.params.userId);
  const admin = req.admin; // messo da requireAdmin
  const user = await prisma.user.findUnique({ where: { id: targetId } });
  if (!user) return res.status(404).json({ message: "Utente non trovato" });

  const userToken = signToken({ id: user.id, imp: true, by: admin.id });
  const adminToken = signToken({ id: admin.id, purpose: "impersonator" });

  res
    .cookie("token", userToken, { httpOnly: true, sameSite: "lax", path: "/" })
    .cookie("impersonator", adminToken, { httpOnly: true, sameSite: "lax", path: "/" })
    .json({ ok: true });
});

/** POST /api/admin/stop-impersonate
 *  Torna all'admin originale, leggendo il cookie 'impersonator'.
 */
router.post("/stop-impersonate", async (req, res) => {
  const impersonator = req.cookies?.impersonator;
  if (!impersonator) return res.status(400).json({ message: "Nessuna impersonificazione attiva" });

  try {
    const payload: any = jwt.verify(impersonator, process.env.JWT_SECRET as string);
    const adminId = payload?.id;
    if (!adminId) throw new Error("Token impersonator invalido");

    const token = signToken({ id: adminId });
    res
      .cookie("token", token, { httpOnly: true, sameSite: "lax", path: "/" })
      .clearCookie("impersonator", { path: "/" })
      .json({ ok: true });
  } catch {
    return res.status(400).json({ message: "Token impersonator non valido" });
  }
});

export default router;


Crea inoltre server/src/routes/me.ts (serve al frontend per mostrare banner “stai impersonando”):

import { Router } from "express";
import { PrismaClient } from "@prisma/client";
import jwt from "jsonwebtoken";

const prisma = new PrismaClient();
const router = Router();

router.get("/", async (req: any, res) => {
  const token = req.cookies?.token;
  if (!token) return res.status(200).json({ user: null, impersonating: false });

  try {
    const payload: any = jwt.verify(token, process.env.JWT_SECRET as string);
    const user = await prisma.user.findUnique({
      where: { id: payload.id },
      select: { id: true, email: true, username: true, role: true },
    });

    const impersonating = Boolean(payload?.imp);
    res.json({ user, impersonating });
  } catch {
    res.json({ user: null, impersonating: false });
  }
});

export default router;


Registra le rotte in server/src/index.ts:

import cookieParser from "cookie-parser";
import { requireAdmin } from "./middleware/requireAdmin";
import adminRouter from "./routes/admin";
import meRouter from "./routes/me";

// ... app = express();
app.use(cookieParser());

// Rotte esistenti (auth, links, profile, redirect, etc.)

app.use("/api/me", meRouter);
app.use("/api/admin", requireAuth, requireAdmin, adminRouter);


(Assumi che requireAuth esista già; altrimenti crea un middleware analogo che rifiuta se manca il cookie JWT valido.)

4) Script una-tantum per promuoverti ADMIN

Crea server/scripts/makeAdmin.mjs:

import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

const email = process.argv[2];
if (!email) {
  console.error("Uso: node server/scripts/makeAdmin.mjs email@example.com");
  process.exit(1);
}

const user = await prisma.user.update({
  where: { email },
  data: { role: "ADMIN" }
}).catch(() => null);

if (!user) {
  console.error("Utente non trovato:", email);
  process.exit(1);
}

console.log("✅ Promosso ADMIN:", user.email);
await prisma.$disconnect();


Esegui:

node server/scripts/makeAdmin.mjs TUO_EMAIL_ADMIN

5) Frontend: barra “Impersonando” + pagina /admin
5.1 AdminBar (banner globale)

Crea client/src/components/AdminBar.tsx:

import { useEffect, useState } from "react";

export default function AdminBar() {
  const [state, setState] = useState<{impersonating:boolean}>({ impersonating: false });

  useEffect(() => {
    fetch("/api/me", { credentials: "include" })
      .then(r => r.json())
      .then(d => setState({ impersonating: d?.impersonating }));
  }, []);

  if (!state.impersonating) return null;

  const stop = async () => {
    await fetch("/api/admin/stop-impersonate", { method: "POST", credentials: "include" });
    window.location.reload();
  };

  return (
    <div className="fixed top-0 left-0 right-0 z-50 bg-yellow-500 text-black text-sm px-4 py-2 flex items-center justify-between">
      <span>Stai impersonando un utente. Le azioni verranno eseguite come lui.</span>
      <button onClick={stop} className="underline">Stop impersona</button>
    </div>
  );
}


Importa AdminBar in client/src/App.tsx (o nel layout principale) sopra al resto dell’app.

5.2 Pagina Admin

Crea client/src/routes/Admin.tsx:

import { useEffect, useState } from "react";

type UserRow = {
  id: number;
  email: string;
  username: string;
  role: "USER" | "ADMIN";
  _count: { links: number };
};

export default function Admin() {
  const [query, setQuery] = useState("");
  const [page, setPage] = useState(1);
  const [pageSize] = useState(20);
  const [users, setUsers] = useState<UserRow[]>([]);
  const [total, setTotal] = useState(0);
  const [stats, setStats] = useState<{usersCount:number;linksCount:number;clicksAllTime:number;clicks7d:number;clicks30d:number} | null>(null);

  useEffect(() => {
    fetch(`/api/admin/users?query=${encodeURIComponent(query)}&page=${page}&pageSize=${pageSize}`, { credentials: "include" })
      .then(r => r.json())
      .then(d => { setUsers(d.users || []); setTotal(d.total || 0); });
  }, [query, page, pageSize]);

  useEffect(() => {
    fetch("/api/admin/stats/summary", { credentials: "include" })
      .then(r => r.json())
      .then(setStats);
  }, []);

  const impersona = async (id: number) => {
    await fetch(`/api/admin/impersonate/${id}`, { method: "POST", credentials: "include" });
    window.location.href = "/dashboard";
  };

  const pages = Math.max(1, Math.ceil(total / pageSize));

  return (
    <div className="container mx-auto px-4 py-6 text-white">
      <h1 className="text-2xl font-bold mb-4">Admin</h1>

      <div className="grid md:grid-cols-3 gap-4 mb-6">
        <StatCard title="Utenti" value={stats?.usersCount ?? 0} />
        <StatCard title="Link" value={stats?.linksCount ?? 0} />
        <StatCard title="Click (totali)" value={stats?.clicksAllTime ?? 0} />
        <StatCard title="Click 7g" value={stats?.clicks7d ?? 0} />
        <StatCard title="Click 30g" value={stats?.clicks30d ?? 0} />
      </div>

      <div className="mb-4 flex items-center gap-2">
        <input
          value={query}
          onChange={e => { setQuery(e.target.value); setPage(1); }}
          placeholder="Cerca per email / username / display name"
          className="w-full rounded-xl border border-white/20 bg-black/50 px-4 py-2 outline-none focus:border-yellow-500"
        />
      </div>

      <div className="rounded-2xl border border-white/10 overflow-hidden">
        <table className="w-full text-left">
          <thead className="bg-white/5 text-white/60">
            <tr>
              <th className="p-3">Email</th>
              <th className="p-3">Username</th>
              <th className="p-3">Ruolo</th>
              <th className="p-3"># Link</th>
              <th className="p-3 w-1">Azioni</th>
            </tr>
          </thead>
          <tbody>
            {users.map(u => (
              <tr key={u.id} className="border-t border-white/10">
                <td className="p-3">{u.email}</td>
                <td className="p-3">{u.username}</td>
                <td className="p-3">{u.role}</td>
                <td className="p-3">{u._count?.links ?? 0}</td>
                <td className="p-3">
                  <button onClick={() => impersona(u.id)} className="px-3 py-1 rounded-lg bg-yellow-500 text-black">Impersona</button>
                </td>
              </tr>
            ))}
            {users.length === 0 && (
              <tr><td className="p-3 text-white/60" colSpan={5}>Nessun utente</td></tr>
            )}
          </tbody>
        </table>
      </div>

      <div className="mt-4 flex items-center gap-2">
        <button disabled={page<=1} onClick={() => setPage(p=>p-1)} className="px-3 py-1 rounded-lg border border-white/20">« Prev</button>
        <span className="text-white/60">Pagina {page} di {pages}</span>
        <button disabled={page>=pages} onClick={() => setPage(p=>p+1)} className="px-3 py-1 rounded-lg border border-white/20">Next »</button>
      </div>
    </div>
  );
}

function StatCard({ title, value }: { title: string; value: number }) {
  return (
    <div className="rounded-2xl border border-white/10 p-4 bg-white/5">
      <div className="text-white/60 text-sm">{title}</div>
      <div className="text-2xl font-bold mt-1">{value}</div>
    </div>
  );
}


Aggiungi la rotta in client/src/App.tsx (o dove definisci le route):

import Admin from "./routes/Admin";
// ...
<Route path="/admin" element={<Admin />} />


E importa <AdminBar /> nel layout principale per mostrare il banner quando stai impersonando.

6) Uso

Promuovi te stesso a ADMIN:

node server/scripts/makeAdmin.mjs LA-TUA-EMAIL


Vai a /admin (mentre sei loggato col tuo account admin).

Cerca un utente → clicca Impersona → verrai portato alla sua /dashboard.

In alto compare il banner giallo “Stai impersonando …” → Stop impersona per tornare admin.

7) Sicurezza

Solo gli utenti con role = ADMIN possono accedere a /api/admin/*.

L’impersonificazione memorizza un cookie “impersonator” firmato per poter tornare indietro in modo sicuro.

Logga l’uso dell’impersonificazione se vuoi audit (facile da aggiungere).

Criteri di accettazione

/admin accessibile solo agli admin.

Lista utenti con ricerca/paginazione, conteggio link.

Impersona funziona e porta alla dashboard del cliente.

Stop impersona ripristina la sessione dell’admin.

Stats globali visibili (utenti, link, click totali e 7/30 giorni se Click è presente).